
#AIM : Implement Merge Sort using the Divide and Conquer approach.
#CODE:
import time import random def
merge_sort(arr): if len(arr) > 1: mid =
len(arr) // 2 left_half = arr[:mid]
right_half = arr[mid:]
merge_sort(left_half)
merge_sort(right_half) i = j = k = 0
while i < len(left_half) and j < len(right_half):
if left_half[i] < right_half[j]:
arr[k] = left_half[i] i
+= 1 else: arr[k] =
right_half[j] j += 1
k += 1 while i <
len(left_half): arr[k]
= left_half[i] i += 1
k += 1 while j <
len(right_half): arr[k]
= right_half[j] j += 1
k += 1
def selection_sort(arr):
comparisons = 0
swaps = 0 n =
len(arr) for i in
range(n):
min_idx = i for j
in range(i + 1, n):
comparisons += 1
if arr[j] < arr[min_idx]:
min_idx = j if min_idx != i:
arr[i], arr[min_idx] = arr[min_idx],
arr[i] swaps += 1
return comparisons, swaps
datasets = {
"Already Sorted": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25],
"Reverse Sorted": [25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
"Random Order": [16, 1, 4, 2, 12, 9, 10, 3, 5, 24, 14, 20, 6, 23, 7, 25, 19, 18, 8, 22, 11, 17, 13, 15, 21],

"Nearly Sorted": [24, 25, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 1, 2],
"Single Element at the End": [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
24, 25, 1],
}
results = []
for name, data in datasets.items():
merge_data = data[:] start_time =
time.time() merge_sort(merge_data)
merge_sort_time = time.time() - start_time
selection_data = data[:] comparisons, swaps =
selection_sort(selection_data)
results.append([name, merge_sort_time, comparisons, swaps])
print("{:<30} {:<20} {:<30} {:<20}".format("Dataset", "Merge Sort Time (s)", "Selection
Sort Comparisons", "Selection Sort Swaps")) print("-" * 100)
for row in results:
print("{:<30} {:<20.6f} {:<30} {:<20}".format(row[0], row[1], row[2], row[3]))
#OUTPUT:

